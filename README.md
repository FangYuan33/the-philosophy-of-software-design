### [《软件设计的哲学》](https://yingang.github.io/aposd2e-zh/)

增量开发（如敏捷开发）意味着 **永远不会完成软件设计**，开发人员在系统的整个生命周期中应始终在思考设计问题；增量开发还意味着不断的重新设计。系统或组件的初始设计几乎从来都不是最好的，随着经验累积，不可避免地会产生更好的设计方式。作为软件开发人员，应该始终在寻找机会来改进现有系统设计，并且应该计划将部分时间花费在设计改进上。

### 2

评价系统是否复杂的我觉得可以从两方面考虑：一是代码的可读性；二是是否易于扩展。可读性这一点我觉得相对来说是难以控制的，比如在某个业务逻辑下，这段代码是否好读，很大程度上取决于写这段代码的人的代码风格，而代码风格又是很主观的，而且通常情况下并不会有强制的规则来要求代码规范，只是会借助一些代码扫描工具来尽可能的推动，这就会会导致需要花费较多的经历去理解才能完成较小的改进。当然，抛开不同的代码风格影响，我觉得代码可读性还受系统设计的影响，合理的设计让代码在结构上是容易理解的，而过度设计和抽象则会让人一头雾水。关于是否易于扩展，我觉得是一个更加客观的指标，一个系统是否易于扩展，取决于系统的设计是否符合**开闭原则**，是否符合**单一职责原则**，是否符合依赖倒置原则等等，凡是符合这些原则的，当开发者在书写相关的代码时，会非常直观的感受到做起来是多么轻松和容易，如果从成本和收益的角度来评估的话，扩展性更好的系统可以投入更少的人力来完成更大的改进。

当无法孤立地理解和修改给定的一段代码时，便存在依赖关系。依赖关系是软件的基本组成部分，不能完全消除，比如方法的签名创建了方法实现方和方法调用方之间的依赖关系：如果向方法添加了一个新参数，则必须修改调用该方法的代码以指定该参数。但是，软件设计的目标之一是减少依赖关系的数量，并使依赖关系保持尽可能简单和明显。之前修改的系统中“增加渠道”要更改一串系统，就是很强的依赖性的体现，同样的渠道在不同的系统间以不同的枚举值维护，但是其表示的含义都是一样的。

另一个复杂性的体现是模糊性，同一个变量名用于两个不同的目的或者声明的魔数并没有注释上明确的含义，那么开发人员就无法清楚地知道某个特定变量的目的是什么。

复杂性不是由单个灾难性错误引起的；它是累积的表现。单个依赖项或模糊项本身不太可能显著影响软件系统的可维护性，而且如果这段代码不再需要变更，那么通常也不会影响什么。之所以会出现复杂性，是因为随着时间的流逝，成千上万的小依赖项和模糊项逐渐形成。最终，这些小问题太多了，以至于对系统的每次更改都会受到其中几个问题的影响。

复杂性来自于依赖性和模糊性的积累。
