### [《软件设计的哲学》](https://yingang.github.io/aposd2e-zh/)

增量开发（如敏捷开发）意味着 **永远不会完成软件设计**，开发人员在系统的整个生命周期中应始终在思考设计问题；增量开发还意味着不断的重新设计。系统或组件的初始设计几乎从来都不是最好的，随着经验累积，不可避免地会产生更好的设计方式。作为软件开发人员，应该始终在寻找机会来改进现有系统设计，并且应该计划将部分时间花费在设计改进上。

### 2

评价系统是否复杂的我觉得可以从两方面考虑：一是代码的可读性；二是是否易于扩展。可读性这一点我觉得相对来说是难以控制的，比如在某个业务逻辑下，这段代码是否好读，很大程度上取决于写这段代码的人的代码风格，而代码风格又是很主观的，而且通常情况下并不会有强制的规则来要求代码规范，只是会借助一些代码扫描工具来尽可能的推动，这就会会导致需要花费较多的经历去理解才能完成较小的改进。当然，抛开不同的代码风格影响，我觉得代码可读性还受系统设计的影响，合理的设计让代码在结构上是容易理解的，而过度设计和抽象则会让人一头雾水。关于是否易于扩展，我觉得是一个更加客观的指标，一个系统是否易于扩展，取决于系统的设计是否符合**开闭原则**，是否符合**单一职责原则**，是否符合依赖倒置原则等等，凡是符合这些原则的，当开发者在书写相关的代码时，会非常直观的感受到做起来是多么轻松和容易，如果从成本和收益的角度来评估的话，扩展性更好的系统可以投入更少的人力来完成更大的改进。

当无法孤立地理解和修改给定的一段代码时，便存在依赖关系。依赖关系是软件的基本组成部分，不能完全消除，比如方法的签名创建了方法实现方和方法调用方之间的依赖关系：如果向方法添加了一个新参数，则必须修改调用该方法的代码以指定该参数。但是，软件设计的目标之一是减少依赖关系的数量，并使依赖关系保持尽可能简单和明显。之前修改的系统中“增加渠道”要更改一串系统，就是很强的依赖性的体现，同样的渠道在不同的系统间以不同的枚举值维护，但是其表示的含义都是一样的。

另一个复杂性的体现是模糊性，同一个变量名用于两个不同的目的或者声明的魔数并没有注释上明确的含义，那么开发人员就无法清楚地知道某个特定变量的目的是什么。

复杂性不是由单个灾难性错误引起的；它是累积的表现。单个依赖项或模糊项本身不太可能显著影响软件系统的可维护性，而且如果这段代码不再需要变更，那么通常也不会影响什么。之所以会出现复杂性，是因为随着时间的流逝，成千上万的小依赖项和模糊项逐渐形成。最终，这些小问题太多了，以至于对系统的每次更改都会受到其中几个问题的影响。

复杂性来自于依赖性和模糊性的积累。

### 3

战术式编程：能用就行，暴铺式开发完成快速交付，像龙卷风一样，所到之处都是混乱的，没有任何规划和设计，这就会使得复杂性不断的累积，最终导致需求开发成本增加，重构可能是有帮助的，但是解决一两个问题似乎区别不大，而解决所有需要几个月的时间导致日程安排没办法接受这种延迟，所以会一直陷入在这种恶性循环中

战略式编程：是长期的事情，仅仅“能用”是远远不够的，引入复杂性来完成开发工作是不可接受的，长远看是成本更低的一种选择。最重要的工作是帮助已有的代码完成 **扩展**

建议将总开发时间的 10% 到 20% 用于投资技术建设

即使在初创公司需要尽快发布产品的情况下，采取战术式编程也并不是一个好的选择，因为这种方法很有可能并不会加快交付速度，而且应该意识到，一旦代码库变成了一坨意大利面，几乎是不能够修复的，而且在产品的生命周期内，很可能需要付出高昂的成本。

公司成功的最重要因素之一是工程师的素质，降低开发成本的最佳方法是聘请优秀的工程师：他们的成本不会比普通工程师高很多，但生产率却高得多，而且他们会对良好的设计感兴趣，一旦不重视良好设计的原则或者公司内缺乏工程师土壤，这家公司不会被优秀的工程师青睐，比较鲜明的例子就是 Facebook。而采用战略式编程的 Google 在硅谷拥有极好的声誉也极为成功（这些例子表明，使用任何一种方法公司都有可能成功。但是，在一家关心软件设计并拥有整洁代码库的公司中工作会有趣得多）

**一旦开始延迟设计改进，就很容易使延迟永久化**

### 4

将模块的接口与其实现分开，便能将其复杂性隐藏起来。

将模块设计成“深”的，是本章比较重要的启示，它在其中提到了多类症是与代码整洁之道相反的理论

### 5

信息隐藏是实现深模块的重要方式。在读本章时，其中提到了信息和知识两个名词，起初为了读起来通顺，将两者全部视为一个概念，但是在我了解了“最少知识原则（一个类对于其他类知道的越少越好）”时，“知识（knowledge）”也是软件开发中的重要概念，而且用它形容一个模块或类中的信息也更为准确

它提出了适当使类稍大一些来完成信息隐藏，这一点与《代码整洁之道》提出的观点相反。这样可以减少类的数量，并且在类中尽可能的隐藏了“知识”

时间顺序分解是开发中常出现的一个问题，往往我们会根据先做什么再做什么来抽象接口，但是往往接口中处理逻辑的步骤是可以合并的，这样能够隐藏更多的知识。书中提出了“读取特定格式的文件，修改文件内容，然后再次将文件写入”的例子，因为文件读取和文件写入步骤都有文件格式相关的知识，这会导致信息泄露，所以将前两步合并，可以用于解决该问题，并且开放出的接口更简单
